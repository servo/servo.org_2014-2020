{"id":"ZNX043","version":15,"snippetIdentifier":"ZNX043-15","jsonPayload":"{\"code\":\"// VR controller trigger to grab, release to throw\\r\\n// Controller secondary button to reset objects\\r\\n\\r\\nvar createScene = async function () {\\r\\n    // Setup scene\\r\\n    var scene = new BABYLON.Scene(engine);\\r\\n    scene.clearColor = colors.navy;\\r\\n\\r\\n    // Create materials\\r\\n    var materials = {\\r\\n        blue: createMat(scene, colors.blue),\\r\\n        red: createMat(scene, colors.red),\\r\\n        navy: createMat(scene, colors.navy),\\r\\n        green: createMat(scene, colors.green)\\r\\n    }\\r\\n    scene.defaultMaterial = materials.navy;\\r\\n\\r\\n    // Environment\\r\\n    var light = new BABYLON.HemisphericLight(\\\"\\\", new BABYLON.Vector3(0.1, 1, 0.3), scene);\\r\\n    light.intensity = 0.3;\\r\\n    var pointLight = new BABYLON.PointLight(\\\"light1\\\", new BABYLON.Vector3(3, 10, 10), scene);\\r\\n    pointLight.position.y = 5;\\r\\n    pointLight.intensity = 0.7;\\r\\n    var camera = new BABYLON.FreeCamera(\\\"camera1\\\", new BABYLON.Vector3(0, 0, -4), scene);\\r\\n    camera.minZ = 0;\\r\\n\\r\\n    // Use Ammo physics plugin\\r\\n    scene.enablePhysics(new BABYLON.Vector3(0, -9.8, 0), new BABYLON.AmmoJSPlugin());\\r\\n\\r\\n    // physics scene\\r\\n    var ground = BABYLON.Mesh.CreateBox(\\\"Ground\\\", 1, scene);\\r\\n    ground.scaling = new BABYLON.Vector3(100, 1, 100);\\r\\n    ground.position.y = -2.0;\\r\\n    ground.physicsImpostor = new BABYLON.PhysicsImpostor(ground, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, friction: 0.5, restitution: 0.7 }, scene);\\r\\n\\r\\n    var table = BABYLON.Mesh.CreateBox(\\\"table\\\", 1, scene);\\r\\n    table.scaling = new BABYLON.Vector3(1, 3, 1);\\r\\n    table.position.y = -2.0;\\r\\n    table.position.z = -2.9;\\r\\n    table.physicsImpostor = new BABYLON.PhysicsImpostor(table, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, friction: 0.5, restitution: 0.7 }, scene);\\r\\n\\r\\n    // Import mesh and set colliders\\r\\n    var newMeshes = (await BABYLON.SceneLoader.ImportMeshAsync(\\\"\\\", \\\"./playground.babylonjs.com/scenes/\\\", \\\"skull.babylon\\\", scene)).meshes;\\r\\n\\r\\n    // Scale loaded mesh\\r\\n    newMeshes[0].scaling.scaleInPlace(0.01);\\r\\n    newMeshes[0].position.set(0, 0, 0);\\r\\n    newMeshes[0].isVisible = false;\\r\\n    var boundingMinMax = newMeshes[0].getHierarchyBoundingVectors()\\r\\n    var bounds = boundingMinMax.max.subtract(boundingMinMax.min);\\r\\n    var grabObjects = new Array();\\r\\n    for (var i = 0; i < 4; i++) {\\r\\n        var instance = newMeshes[0].createInstance(i + \\\"index\\\");\\r\\n        // Add colliders\\r\\n        var collidersVisible = false;\\r\\n        var sphereCollider = BABYLON.Mesh.CreateSphere(\\\"sphere1\\\", 16, 0.5, scene);\\r\\n        sphereCollider.position.y = 0.08;\\r\\n        sphereCollider.isVisible = collidersVisible;\\r\\n        var boxCollider = BABYLON.Mesh.CreateBox(\\\"box1\\\", 0.3, scene);\\r\\n        boxCollider.position.y = -0.13;\\r\\n        boxCollider.position.z = -0.13;\\r\\n        boxCollider.isVisible = collidersVisible;\\r\\n\\r\\n        // Create a physics root and add all children\\r\\n        var physicsRoot = BABYLON.Mesh.CreateBox(\\\" \\\", 1, scene); //new BABYLON.Mesh(\\\"\\\", scene);\\r\\n        physicsRoot.scaling.copyFrom(bounds)\\r\\n        physicsRoot.isVisible = false;\\r\\n        physicsRoot.rotationQuaternion = new BABYLON.Quaternion();\\r\\n        physicsRoot.addChild(instance);\\r\\n        physicsRoot.addChild(boxCollider);\\r\\n        physicsRoot.addChild(sphereCollider);\\r\\n        physicsRoot.position.y += 3;\\r\\n        physicsRoot.scaling.scaleInPlace(0.3);\\r\\n\\r\\n        // Enable physics on colliders first then physics root of the mesh\\r\\n        boxCollider.physicsImpostor = new BABYLON.PhysicsImpostor(boxCollider, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0 }, scene);\\r\\n        sphereCollider.physicsImpostor = new BABYLON.PhysicsImpostor(sphereCollider, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 0 }, scene);\\r\\n        physicsRoot.physicsImpostor = new BABYLON.PhysicsImpostor(physicsRoot, BABYLON.PhysicsImpostor.NoImpostor, { mass: 3 }, scene);\\r\\n\\r\\n        // Orient the physics root\\r\\n        physicsRoot.rotation.x = Math.PI / 5;\\r\\n        physicsRoot.rotation.z = Math.PI / 6;\\r\\n        physicsRoot.position.y += i\\r\\n        physicsRoot.position.z -= 2.9\\r\\n        grabObjects.push(physicsRoot);\\r\\n    }\\r\\n\\r\\n    // Initialize webXR\\r\\n    var xr = await scene.createDefaultXRExperienceAsync({ floorMeshes: [ground] });\\r\\n    xr.baseExperience.onStateChangedObservable.add((state)=>{\\r\\n        if(state === BABYLON.WebXRState.IN_XR){\\r\\n            // When entering webXR, position the user's feet at 0,-2, 0\\r\\n            xr.baseExperience.setPositionOfCameraUsingContainer(new BABYLON.Vector3(0,xr.baseExperience.camera.position.y -2,0))\\r\\n        }        \\r\\n    })\\r\\n\\r\\n    // Setup controller data\\r\\n    var controllers = [\\r\\n        {\\r\\n            hand: \\\"left\\\",\\r\\n            vrController: null,\\r\\n            mesh: BABYLON.Mesh.CreateBox(\\\"\\\", 0.1, scene),\\r\\n            lastTriggerValue: 0,\\r\\n            secondaryButtonValue: 0,\\r\\n            selectedMesh: null,\\r\\n            virtualSelected: new BABYLON.AbstractMesh(\\\"\\\", scene),\\r\\n        },\\r\\n        {\\r\\n            hand: \\\"right\\\",\\r\\n            vrController: null,\\r\\n            mesh: BABYLON.Mesh.CreateBox(\\\"\\\", 0.1, scene),\\r\\n            lastTriggerValue: 0,\\r\\n            secondaryButtonValue: 0,\\r\\n            selectedMesh: null,\\r\\n            virtualSelected: new BABYLON.AbstractMesh(\\\"\\\", scene),\\r\\n        }\\r\\n    ]\\r\\n    controllers.forEach((controller) => {\\r\\n        controller.mesh.rotationQuaternion = new BABYLON.Quaternion();\\r\\n        controller.mesh.scaling.z = 2;\\r\\n        controller.mesh.isVisible = false;\\r\\n        controller.virtualSelected.parent = controller.mesh;\\r\\n        controller.virtualSelected.rotationQuaternion = new BABYLON.Quaternion();\\r\\n    });\\r\\n\\r\\n    xr.input.onControllerAddedObservable.add((ctrl) => {\\r\\n        let controller = controllers[1];\\r\\n        if (ctrl.inputSource.handedness === \\\"left\\\") {\\r\\n            controller = controllers[0];\\r\\n        }\\r\\n        controller.vrController = ctrl;\\r\\n        controller.mesh.isVisible = true;\\r\\n\\r\\n        // Make controller NoImpostor with mass of 0, this makes it pass through objects but still gets updated kinematic velocity data used when grabbing\\r\\n        controller.mesh.physicsImpostor = new BABYLON.PhysicsImpostor(controller.mesh, BABYLON.PhysicsImpostor.NoImpostor, { mass: 0 }, scene);\\r\\n\\r\\n        // Controller events\\r\\n        controller.vrController.gamepadController.onSecondaryButtonStateChangedObservable.add((state) => {\\r\\n            controller.secondaryButtonValue = state.value;\\r\\n        })\\r\\n        controller.vrController.gamepadController.onTriggerStateChangedObservable.add((state) => {\\r\\n            if ((!state.pressed && controller.selectedMesh) || (controller.lastTriggerValue > 0.1 && state.value <= 0.1 && controller.selectedMesh)) {\\r\\n                var angularVelocity = controller.mesh.physicsImpostor.getAngularVelocity();\\r\\n                controller.selectedMesh.physicsImpostor.setAngularVelocity(angularVelocity);\\r\\n                controller.selectedMesh = null;\\r\\n            }\\r\\n\\r\\n            if (state.pressed || (controller.lastTriggerValue < 0.1 && state.value >= 0.1)) {\\r\\n                grabObjects.forEach((s) => {\\r\\n                    if (s.intersectsMesh(controller.mesh, true, false)) {\\r\\n                        // Ungrab if another controller was previously holding it\\r\\n                        controllers.forEach((c) => {\\r\\n                            if (c.selectedMesh == s) {\\r\\n                                c.selectedMesh = null;\\r\\n                            }\\r\\n                        });\\r\\n\\r\\n                        // Grab the object\\r\\n                        controller.selectedMesh = s;\\r\\n                        controller.virtualSelected.setAbsolutePosition(s.position);\\r\\n                        controller.virtualSelected.rotationQuaternion.copyFrom(BABYLON.Quaternion.Inverse(controller.mesh.rotationQuaternion).multiply(s.rotationQuaternion))\\r\\n                    }\\r\\n                });\\r\\n            }\\r\\n            controller.lastTriggerValue = state.value;\\r\\n        })\\r\\n    })\\r\\n\\r\\n    scene.onBeforeRenderObservable.add(() => {\\r\\n        controllers.forEach((controller) => {\\r\\n            if (controller.vrController) {\\r\\n                // Update controller mesh position\\r\\n                controller.mesh.position.copyFrom(controller.vrController.pointer.getAbsolutePosition())\\r\\n                controller.mesh.rotationQuaternion.copyFrom(controller.vrController.pointer.rotationQuaternion)\\r\\n                controller.mesh.computeWorldMatrix();\\r\\n\\r\\n                if (controller.secondaryButtonValue >= 0.9) {\\r\\n                    // Move all objects above controller if the secondary button is pressed\\r\\n                    grabObjects.forEach((sphere, index) => {\\r\\n                        sphere.position.copyFrom(controller.mesh.position)\\r\\n                        sphere.position.addInPlace(controller.mesh.up.scale(index * 0.2 + 0.2))\\r\\n\\r\\n                        // Update linear velocity from hands angular velocity\\r\\n                        //https://www.quora.com/How-is-the-direction-of-angular-and-linear-velocity-related\\r\\n                        var radius = sphere.position.subtract(controller.mesh.position)\\r\\n                        var angularVelocity = controller.mesh.physicsImpostor.getAngularVelocity();\\r\\n                        sphere.physicsImpostor.setLinearVelocity(BABYLON.Vector3.Cross(angularVelocity, radius).add(controller.mesh.physicsImpostor.getLinearVelocity()))\\r\\n                    })\\r\\n                }\\r\\n\\r\\n                if (controller.selectedMesh) {\\r\\n                    // Update grabbed mesh if one exists\\r\\n                    controller.selectedMesh.position.copyFrom(controller.virtualSelected.getAbsolutePosition());\\r\\n                    controller.selectedMesh.rotationQuaternion.copyFrom(controller.mesh.rotationQuaternion.multiply(controller.virtualSelected.rotationQuaternion))\\r\\n                    var radius = controller.selectedMesh.position.subtract(controller.mesh.position)\\r\\n                    var angularVelocity = controller.mesh.physicsImpostor.getAngularVelocity();\\r\\n                    controller.selectedMesh.physicsImpostor.setLinearVelocity(BABYLON.Vector3.Cross(angularVelocity, radius).add(controller.mesh.physicsImpostor.getLinearVelocity()))\\r\\n                    controller.selectedMesh.physicsImpostor.setAngularVelocity(new BABYLON.Vector3());\\r\\n                }\\r\\n            }\\r\\n        })\\r\\n    })\\r\\n\\r\\n    return scene;\\r\\n};\\r\\n\\r\\n// Colors\\r\\nvar colors = {\\r\\n    seaFoam: BABYLON.Color3.FromHexString(\\\"#16a085\\\"),\\r\\n    green: BABYLON.Color3.FromHexString(\\\"#27ae60\\\"),\\r\\n    blue: BABYLON.Color3.FromHexString(\\\"#2980b9\\\"),\\r\\n    purple: BABYLON.Color3.FromHexString(\\\"#8e44ad\\\"),\\r\\n    navy: BABYLON.Color3.FromHexString(\\\"#2c3e50\\\"),\\r\\n    yellow: BABYLON.Color3.FromHexString(\\\"#f39c12\\\"),\\r\\n    orange: BABYLON.Color3.FromHexString(\\\"#d35400\\\"),\\r\\n    red: BABYLON.Color3.FromHexString(\\\"#c0392b\\\"),\\r\\n    white: BABYLON.Color3.FromHexString(\\\"#bdc3c7\\\"),\\r\\n    gray: BABYLON.Color3.FromHexString(\\\"#7f8c8d\\\")\\r\\n}\\r\\n\\r\\n// Create material helper\\r\\nvar createMat = (scene, color) => {\\r\\n    var mat = new BABYLON.StandardMaterial(\\\"\\\", scene);\\r\\n    mat.diffuseColor = color;\\r\\n    mat.specularColor = BABYLON.Color3.FromHexString(\\\"#555555\\\");\\r\\n    mat.specularPower = 1;\\r\\n    mat.emissiveColor = color.clone().scale(0.7);\\r\\n    mat.backFaceCulling = false;\\r\\n    return mat;\\r\\n}\"}","name":"","description":"","tags":""}
